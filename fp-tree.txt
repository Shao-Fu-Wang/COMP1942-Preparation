// FP-growth association
open System.Collections.Generic
type FPNode = { mutable Count: int; Item: string; SubNodes: ResizeArray<FPNode> }
type HeadOfNodeLinks = ResizeArray<string * Stack<FPNode>>
type FPTree = { HeadOfNodeLinks: HeadOfNodeLinks; Root: ResizeArray<FPNode> }

let minSupport = 3
let fpTree =
    // true: start from a grown FP tree, false: grow a new FP tree from transaction records
    if false then
        let orderedIndents = ResizeArray<int * ResizeArray<FPNode>>()
        let headOfNodeLinks = HeadOfNodeLinks()
        let root = ResizeArray<FPNode>()
        """
        Root
          e 9
          d 10
            c 6
                b 5
                    a 4
        """.Split([|"\r\n"; "\n"|], System.StringSplitOptions.RemoveEmptyEntries)
        |> Array.choose (fun row -> Seq.tryFindIndex (System.Char.IsWhiteSpace >> not) row |> Option.map (fun res -> res, row[res..].Split(Unchecked.defaultof<string array>, System.StringSplitOptions.RemoveEmptyEntries)))
        |> Array.iter (fun (indent, info) ->
            if info[0] = "Root" then orderedIndents.Add(indent, root) else
            let newNode = { Item = info[0]; Count = int info[1]; SubNodes = ResizeArray() }
            match headOfNodeLinks |> Seq.tryFind (fun (item, _) -> item = info[0]) with
            | Some (_, head) -> head.Push newNode
            | None -> headOfNodeLinks.Add(info[0], Stack[newNode])
            let parentIndex = orderedIndents.FindLastIndex(fun (i, _) -> i < indent)
            (snd orderedIndents[parentIndex]).Add newNode
            orderedIndents.RemoveRange(parentIndex + 1, orderedIndents.Count - (parentIndex + 1))
            orderedIndents.Add(indent, newNode.SubNodes)
        )
        { HeadOfNodeLinks = headOfNodeLinks; Root = root }
    else
    let data =
        """
        a   b   c   d   e   f   g   h
        a   f   g
        b   d   e   f   j
        a   b   d   i   k
        a   b   e   g
        """.Split([|"\r\n"; "\n"|], System.StringSplitOptions.TrimEntries ||| System.StringSplitOptions.RemoveEmptyEntries)
        |> Array.map (fun s -> s.Split(Unchecked.defaultof<string array>, System.StringSplitOptions.RemoveEmptyEntries))
    let itemFrequency = data |> Array.concat |> Array.countBy id
    printfn "Item frequency:"
    itemFrequency |> Seq.map ((<||) (sprintf "%s: %d")) |> Seq.iter (printfn "%s")
    let orderedItemFrequency = itemFrequency |> Array.filter (fun (_, c) -> c >= minSupport) |> Array.sortBy (fun (item, count) -> -count, item)
    printfn "Ordered item frequency:"
    orderedItemFrequency |> Seq.map ((<||) (sprintf "%s: %d")) |> Seq.iter (printfn "%s")
    let orderedData =
        data |> Array.map (fun row -> row |> Array.filter (fun x -> Array.exists (fst >> (=) x) orderedItemFrequency) |> Array.sortBy (fun x -> Seq.findIndex (fst >> (=) x) orderedItemFrequency))
    printfn "Ordered frequent items:"
    orderedData |> Seq.map (String.concat ", ") |> Seq.iter (printfn "%s")
    let headOfNodeLinks = HeadOfNodeLinks()
    for item, _ in orderedItemFrequency do
        headOfNodeLinks.Add(item, Stack())
    let root = ResizeArray<FPNode>()
    for row in orderedData do
        let mutable searched = root
        for v in row do
            match searched |> Seq.tryFind (fun n -> n.Item = v) with
            | Some n ->
                n.Count <- n.Count + 1
                searched <- n.SubNodes
            | None ->
                let n = { Item = v; Count = 1; SubNodes = ResizeArray() }
                searched.Add n
                searched <- n.SubNodes
                headOfNodeLinks.ForEach(fun (item, head) -> if item = v then head.Push n)
    { HeadOfNodeLinks = headOfNodeLinks; Root = root }
let rec displayTree indents (tree: FPNode ResizeArray) =
    for i in 0..tree.Count-1 do
        for indent in indents do
            printf (if indent then "│   " else "    ")
        printf (if i < tree.Count - 1 then "├───" else "└───")
        printfn $"{tree[i].Item}: {tree[i].Count}"
        displayTree (seq { yield! indents
                           yield i < tree.Count - 1 }) tree[i].SubNodes
printfn "FP Tree (Remember to draw the Frequent Item + Head of Node Link table)"
printfn "Root"
displayTree Seq.empty fpTree.Root
let rec tryLayoutSinglePath (tree: FPNode ResizeArray) =
    match tree.Count with
    | 0 -> Some []
    | 1 -> tryLayoutSinglePath tree[0].SubNodes |> Option.map (fun p -> tree[0]::p)
    | _ -> None
let rec tryProcessSinglePath (totalCondition: string array) tree =
    match tryLayoutSinglePath tree with
    | Some path -> Some(seq {
            let path = path |> Array.ofList
            let ret = ResizeArray(totalCondition, Capacity = totalCondition.Length + path.Length)
            for i in 1..(1 <<< path.Length)-1 do
                let mutable high = 0
                for h in 0..path.Length-1 do
                    if i &&& (1 <<< h) <> 0 then
                        ret.Add path[h].Item
                        high <- h
                ret.ToArray(), path[high].Count
                ret.RemoveRange(totalCondition.Length, ret.Count - totalCondition.Length)
        })
    | None -> None
let rec conditionalFpTree (newCondition: string) (existingConditionsOnTree: string array) (tree: ResizeArray<FPNode>) =
    let totalCondition = [|yield! existingConditionsOnTree
                           newCondition|]
    printfn $"""Generation of conditional FP Tree on {{{String.concat ", " totalCondition}}}"""
    let data = ResizeArray<_>()
    let rec recursivelyAddData (searchPath: string list) (tree: FPNode ResizeArray) =
        for n in tree do
            if n.Item = newCondition then
                data.Add(List.rev (n.Item::searchPath), n.Count)
            else recursivelyAddData (n.Item::searchPath) n.SubNodes
    recursivelyAddData [] tree
    let data = data.ToArray()

    printfn "Path from previous tree:"
    data |> Seq.map (fun (row, count) -> $"""{{{String.concat ", " row}}}: {count}""") |> Seq.iter (printfn "%s")
    let itemFrequency = SortedDictionary()
    for row, count in data do
        for item in row do
            match itemFrequency.TryGetValue item with
            | true, existingCount -> itemFrequency[item] <- existingCount + count
            | false, _ -> itemFrequency[item] <- count
    let itemFrequency = itemFrequency |> Seq.toArray |> Array.map (|KeyValue|)
    printfn "Item frequency:"
    itemFrequency |> Seq.map ((<||) (sprintf "%s: %d")) |> Seq.iter (printfn "%s")
    let orderedItemFrequency = itemFrequency |> Array.filter (fun (_, c) -> c >= minSupport) |> Array.sortBy (fun (item, count) -> -count, item)
    printfn "Ordered item frequency:"
    orderedItemFrequency |> Seq.map ((<||) (sprintf "%s: %d")) |> Seq.iter (printfn "%s")
    let orderedData =
        data |> Array.map (fun (row, count) -> row |> Seq.filter (fun x -> Array.exists (fst >> (=) x) orderedItemFrequency) |> Seq.sortBy (fun x -> Seq.findIndex (fst >> (=) x) orderedItemFrequency), count)
    printfn $"""Conditional pattern base on {{{String.concat ", " totalCondition}}}"""
    orderedData |> Seq.map (fun (row, count) -> $"""{{{String.concat ", " row}}}: {count}""") |> Seq.iter (printfn "%s")
    let headOfNodeLinks = HeadOfNodeLinks()
    for item, _ in orderedItemFrequency do
        headOfNodeLinks.Add(item, Stack())
    let root = ResizeArray<FPNode>()
    for row, count in orderedData do
        let mutable searched = root
        for v in row do
            if v <> newCondition then
                match searched |> Seq.tryFind (fun n -> n.Item = v) with
                | Some n ->
                    n.Count <- n.Count + count
                    searched <- n.SubNodes
                | None ->
                    let n = { Item = v; Count = count; SubNodes = ResizeArray() }
                    searched.Add n
                    searched <- n.SubNodes
                    headOfNodeLinks.ForEach(fun (item, head) -> if item = v then head.Push n)
    let thisCount = orderedItemFrequency |> Seq.pick (fun (name, count) -> if name = newCondition then Some count else None)
    printfn $"""Conditional FP Tree on {{{String.concat ", " totalCondition}}} [{thisCount}] (Remember to draw the Frequent Item + Head of Node Link table)"""
    printfn "Root"
    displayTree Seq.empty root
    seq {
        totalCondition, thisCount
        match tryProcessSinglePath totalCondition root with
        | Some largeItemSets -> yield! largeItemSets
        | None ->
            for i in headOfNodeLinks.Count-1..-1..0 do
                let iterItem = fst headOfNodeLinks[i]
                if iterItem <> newCondition then
                    yield! conditionalFpTree iterItem totalCondition root
    }
seq {
    match tryProcessSinglePath Array.empty fpTree.Root with
    | Some largeItemSets -> yield! largeItemSets
    | None ->
        for i in fpTree.HeadOfNodeLinks.Count-1..-1..0 do
            yield! conditionalFpTree (fst fpTree.HeadOfNodeLinks[i]) Array.empty fpTree.Root
} |> Seq.toArray
|> fun x -> printfn "All large itemsets generated are:"; x
|> Array.iter (fun (items, count) ->
    printfn $"""{{{String.concat ", " items}}}: {count}"""
)